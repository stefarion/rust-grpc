# Advanced Programming - gRPC in Rust
**Nama:**   &nbsp; Stefanus Tan Jaya<br>
**NPM:**    &nbsp;&ensp; 2306152456<br>
**Kelas:**  &nbsp; Pemrograman Lanjut A<br>

### Module 8 Reflection
1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?<br>
    - Dalam **Unary RPC**, klien mengirim satu _request_ ke server, kemudian server memprosesnya dan mengembalikan satu respons ke klien. Metode ini umum digunakan karena sederhana dan mudah di-_debug_. Contoh penggunaannya sebagai pengganti REST API untuk komunikasi antar server.
    - Dalam **Server Streaming RPC**, klien mengirim satu _request_ ke server, kemudian server _stream_ atau mengalirkan banyak respons secara berurutan hingga selesai. Metode ini cocok untuk dataset besar ketika server perlu mengembalikan sejumlah data dengan membaginya menjadi aliran data yang lebih kecil secara berkelanjutan. Contohnya ketika admin memantau log server secara _real‑time_.
    - Dalam **Bi-Directional Streaming RPC**, klien dan server saling membuka _stream_ di mana masing-masing dapat mengirim dan menerima pesan kapan saja secara berkelanjutan. Metode ini cocok untuk skenario yang butuh komunikasi interaktif antara klien dan server secara _real-time_. Contohnya aplikasi _chat_ dan _platform collaborative editing_.
2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?<br>
    - Pada **authentication**, pastikan klien adalah orang yang benar-benar mereka klaim sebenarnya sebelum memberi mereka akses. Contoh implementasinya seperti menggunakan token JWT dan OAuth.
    - Pada **authorization**, pastikan klien yang terautentikasi memiliki izin akses yang sesuai dengan haknya. Contoh implementasinya adalah Role‑Based Access Control (RBAC), Attribute‑Based Access Control (ABAC), dan _principle of least privilege_.
    - Pada **data encryption**, gunakan algoritma enkripsi yang dan perhatikan enkripsi data saat transit dan tidak aktif (_rest_) untuk melindungi data sensitif dari akses tidak sah. Contoh implementasinya adalah sertifikat TLS/SSL.
3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?<br>
    - Tantangan yang harus diperhatikan adalah manajemen alur data untuk menghindari _race condition_ dan sinkronisasi antara klien dan server saat mengirim dan menerima pesan. Selain itu, perhatikan _resource management_ untuk memastikan sumber daya dialokasikan dengan benar dan _load balancing_ untuk menangani lalu lintas koneksi yang besar. 
4. What are the advantages and disadvantages of using the `tokio_stream::wrappers::ReceiverStream` for streaming responses in Rust gRPC services?<br>
    - Salah satu keuntungannya adalah terintegrasi baik dengan Tokio karena `tokio_stream::wrappers::ReceiverStream` mengubah `tokio::sync::mpsc::Receiver` menjadi `Stream` di mana cocok untuk servis gRPC dan ekosistem Tokio. Selain itu, _streaming_ terjadi sepenuhnya secara `async` dan tidak memblokir _thread_ utama. Namun, kekurangannya program menjadi lebih kompleks dan mungkin perlu _error handling_ tambahan untuk memastikan _stream_ ditutup dengan benar.
5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?<br>
    - Untuk mendukung _code reuse_, modularitas, dan mempermudah _maintainability_ serta pengembangan jangka panjang dalam Rust gRPC, _developer_ bisa dapat menerapkan beberapa _best practices_ dan pola pengembangan dengan prinsip SOLID. Beberapa langkah yang bisa diikuti seperti:
        1. Memisahkan _layer_ dengan jelas, seperti proto, _service logic_, _repository_, dsb.
        2. Menggunakan _trait_ untuk abstraksi.
        3. Memisahkan konfigurasi dan inisialisasi.
        4. Menerapkan Dependency Injection.
        5. Mengimplementasikan berbagai tipe _testing_, seperti _unit tests_, _integration tests_, dan _end-to-end tests_.
6. In the **MyPaymentService** implementation, what additional steps might be necessary to handle more complex payment processing logic?<br>
    - Implementasi tambahan yang bisa dipertimbangkan seperti memastikan pengguna terautentikasi sebelum melakukan pembayaran, mengotorisasi pengguna untuk melakukan pembayaran, menangani semua kemungkinan error yang bisa terjadi selama proses pembayaran, dan mencatat aktivitas pengguna dalam audit log. Selain itu, metode RPC bisa diubah menjadi Server Streaming untuk menangani _request_ yang banyak dan mengurangi _overhead_.
7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?<br>
    - Dengan menggunakan gRPC, arsitektur kode beralih ke desain berbasis kontrak (IDL) dengan Protocol Buffer dan komunikasi HTTP/2, sehingga layanan menjadi lebih tipis dan efisien. Karena gRPC mendukung banyak bahasa via `stub` otomatis, interoperabilitas antar layanan menjadi lebih mudah. Secara keseluruhan, gRPC mendorong pola _microservices_ yang lebih terstruktur, kinerja tinggi, dan _cross‑platform_ yang konsisten.
8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?<br>
    - Keuntungan HTTP/2 terletak pada _multiplexing_, yang memungkinkan banyak _request_ dan respons berjalan bersamaan dalam satu koneksi yang berguna untuk mengurangi latensi. Selain itu, HTTP/2 memiliki _header_ yang jauh lebih kecil, kemampuan _server push_ (server dapat mengirim sumber daya tambahan ke klien sebelum di-_request_), dan kemampuan _parsing binary protocol_ yang dapat meningkatkan performa dan mengurangi _overhead_. Kekurangannya terletak pada kompleksitas yang lebih sulit untuk diimplementasi, kemampuan server dan klien lain yang belum _support_ HTTP/2, dan lebih mengonsumsi _resource server_, apalagi ketika menangani banyak koneksi.
9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?<br>
    - Pada REST APIs, komunikasi hanya berjalan searah di mana klien mengirim _request_, menunggu dan menerima respons dari server, kemudian koneksi bisa ditutup. Model ini cocok untuk operasi CRUD sederhana di server, namun tidak ideal untuk komunikasi _real-time_ karena klien harus terus membuat koneksi baru tiap operasi. Sementara dengan Bi-Directional Streaming gRPC, komunikasi dua arah (saling kirim-terima pesan) antara klien dan server terjadi terus-menerus, kapan saja, dan tanpa harus membuat koneksi baru. Model ini mendukung komunikasi _real-time_ dengan tingkat _responsiveness_ yang tinggi.
10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?<br>
    - Dengan pendekatan _schema-based_ gRPC menggunakan Protocol Buffer, skema terdefinisi dengan baik yang dapat membantu memastikan konsistensi dan kompatibilitas antar berbagai layanan dan _platform_. Protocol Buffer juga menyediakan validasi yang kuat dan ketat karena tiap pesan harus sesuai skema proto. Sementara itu, pendekatan tanpa skema dengan JSON dalam REST API menyediakan fleksibilitas yang lebih tinggi, sehingga _payload_ bisa berubah–ubah tanpa perlu definisi formal. Format teks juga mudah dibaca, sehingga mudah di-_debug_. Namun, fleksibilitas ini dapat menyebabkan ketidakpastian tipe data dan kesulitan validasi data secara konsisten. Resiko kesalahan _parsing_ baru ketahuan saat program dijalankan.